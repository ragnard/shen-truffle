"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3705 V3706) (let Curry (shen.curry V3705) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3706)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3708) (cond ((and (cons? V3708) (shen.special? (hd V3708))) (cons (hd V3708) (map (lambda Y (shen.curry Y)) (tl V3708)))) ((and (cons? V3708) (and (cons? (tl V3708)) (shen.extraspecial? (hd V3708)))) V3708) ((and (cons? V3708) (and (= type (hd V3708)) (and (cons? (tl V3708)) (and (cons? (tl (tl V3708))) (= () (tl (tl (tl V3708)))))))) (cons type (cons (shen.curry (hd (tl V3708))) (tl (tl V3708))))) ((and (cons? V3708) (and (cons? (tl V3708)) (cons? (tl (tl V3708))))) (shen.curry (cons (cons (hd V3708) (cons (hd (tl V3708)) ())) (tl (tl V3708))))) ((and (cons? V3708) (and (cons? (tl V3708)) (= () (tl (tl V3708))))) (cons (shen.curry (hd V3708)) (cons (shen.curry (hd (tl V3708))) ()))) (true V3708)))

(defun shen.special? (V3710) (element? V3710 (value shen.*special*)))

(defun shen.extraspecial? (V3712) (element? V3712 (value shen.*extraspecial*)))

(defun shen.t* (V3717 V3718 V3719 V3720) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3719) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3719 (freeze (bind Error (shen.errormaxinfs) V3719 V3720))))) (if (= Case false) (let Case (let V3697 (shen.lazyderef V3717 V3719) (if (= fail V3697) (do (shen.incinfs) (cut Throwcontrol V3719 (freeze (shen.prolog-failure V3719 V3720)))) false)) (if (= Case false) (let Case (let V3698 (shen.lazyderef V3717 V3719) (if (cons? V3698) (let X (hd V3698) (let V3699 (shen.lazyderef (tl V3698) V3719) (if (cons? V3699) (let V3700 (shen.lazyderef (hd V3699) V3719) (if (= : V3700) (let V3701 (shen.lazyderef (tl V3699) V3719) (if (cons? V3701) (let A (hd V3701) (let V3702 (shen.lazyderef (tl V3701) V3719) (if (= () V3702) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3719 (freeze (cut Throwcontrol V3719 (freeze (shen.th* X A V3718 V3719 V3720)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3719) (do (shen.incinfs) (shen.show V3717 V3718 V3719 (freeze (bind Datatypes (value shen.*datatypes*) V3719 (freeze (shen.udefs* V3717 V3718 Datatypes V3719 V3720))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3726) (cond ((= + V3726) (set shen.*shen-type-theory-enabled?* true)) ((= - V3726) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3737 V3738) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3744 V3745 V3746 V3747 V3748) (let Case (let V3693 (shen.lazyderef V3746 V3747) (if (cons? V3693) (let D (hd V3693) (do (shen.incinfs) (call (cons D (cons V3744 (cons V3745 ()))) V3747 V3748))) false)) (if (= Case false) (let V3694 (shen.lazyderef V3746 V3747) (if (cons? V3694) (let Ds (tl V3694) (do (shen.incinfs) (shen.udefs* V3744 V3745 Ds V3747 V3748))) false)) Case)))

(defun shen.th* (V3754 V3755 V3756 V3757 V3758) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3754 (cons : (cons V3755 ()))) V3756 V3757 (freeze (fwhen false V3757 V3758)))) (if (= Case false) (let Case (let F (shen.newpv V3757) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3754 V3757)) V3757 (freeze (bind F (shen.sigf (shen.lazyderef V3754 V3757)) V3757 (freeze (call (cons F (cons V3755 ())) V3757 V3758))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3754 V3755 V3757 V3758)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3754 V3755 V3756 V3757 V3758)) (if (= Case false) (let Case (let V3589 (shen.lazyderef V3754 V3757) (if (cons? V3589) (let F (hd V3589) (let V3590 (shen.lazyderef (tl V3589) V3757) (if (= () V3590) (do (shen.incinfs) (shen.th* F (cons --> (cons V3755 ())) V3756 V3757 V3758)) false))) false)) (if (= Case false) (let Case (let V3591 (shen.lazyderef V3754 V3757) (if (cons? V3591) (let F (hd V3591) (let V3592 (shen.lazyderef (tl V3591) V3757) (if (cons? V3592) (let X (hd V3592) (let V3593 (shen.lazyderef (tl V3592) V3757) (if (= () V3593) (let B (shen.newpv V3757) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3755 ()))) V3756 V3757 (freeze (shen.th* X B V3756 V3757 V3758))))) false))) false))) false)) (if (= Case false) (let Case (let V3594 (shen.lazyderef V3754 V3757) (if (cons? V3594) (let V3595 (shen.lazyderef (hd V3594) V3757) (if (= cons V3595) (let V3596 (shen.lazyderef (tl V3594) V3757) (if (cons? V3596) (let X (hd V3596) (let V3597 (shen.lazyderef (tl V3596) V3757) (if (cons? V3597) (let Y (hd V3597) (let V3598 (shen.lazyderef (tl V3597) V3757) (if (= () V3598) (let V3599 (shen.lazyderef V3755 V3757) (if (cons? V3599) (let V3600 (shen.lazyderef (hd V3599) V3757) (if (= list V3600) (let V3601 (shen.lazyderef (tl V3599) V3757) (if (cons? V3601) (let A (hd V3601) (let V3602 (shen.lazyderef (tl V3601) V3757) (if (= () V3602) (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (if (shen.pvar? V3602) (do (shen.bindv V3602 () V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3602 V3757) Result))) false)))) (if (shen.pvar? V3601) (let A (shen.newpv V3757) (do (shen.bindv V3601 (cons A ()) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3601 V3757) Result)))) false))) (if (shen.pvar? V3600) (do (shen.bindv V3600 list V3757) (let Result (let V3603 (shen.lazyderef (tl V3599) V3757) (if (cons? V3603) (let A (hd V3603) (let V3604 (shen.lazyderef (tl V3603) V3757) (if (= () V3604) (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (if (shen.pvar? V3604) (do (shen.bindv V3604 () V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3604 V3757) Result))) false)))) (if (shen.pvar? V3603) (let A (shen.newpv V3757) (do (shen.bindv V3603 (cons A ()) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3603 V3757) Result)))) false))) (do (shen.unbindv V3600 V3757) Result))) false))) (if (shen.pvar? V3599) (let A (shen.newpv V3757) (do (shen.bindv V3599 (cons list (cons A ())) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons list (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3599 V3757) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3605 (shen.lazyderef V3754 V3757) (if (cons? V3605) (let V3606 (shen.lazyderef (hd V3605) V3757) (if (= @p V3606) (let V3607 (shen.lazyderef (tl V3605) V3757) (if (cons? V3607) (let X (hd V3607) (let V3608 (shen.lazyderef (tl V3607) V3757) (if (cons? V3608) (let Y (hd V3608) (let V3609 (shen.lazyderef (tl V3608) V3757) (if (= () V3609) (let V3610 (shen.lazyderef V3755 V3757) (if (cons? V3610) (let A (hd V3610) (let V3611 (shen.lazyderef (tl V3610) V3757) (if (cons? V3611) (let V3612 (shen.lazyderef (hd V3611) V3757) (if (= * V3612) (let V3613 (shen.lazyderef (tl V3611) V3757) (if (cons? V3613) (let B (hd V3613) (let V3614 (shen.lazyderef (tl V3613) V3757) (if (= () V3614) (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (if (shen.pvar? V3614) (do (shen.bindv V3614 () V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (do (shen.unbindv V3614 V3757) Result))) false)))) (if (shen.pvar? V3613) (let B (shen.newpv V3757) (do (shen.bindv V3613 (cons B ()) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (do (shen.unbindv V3613 V3757) Result)))) false))) (if (shen.pvar? V3612) (do (shen.bindv V3612 * V3757) (let Result (let V3615 (shen.lazyderef (tl V3611) V3757) (if (cons? V3615) (let B (hd V3615) (let V3616 (shen.lazyderef (tl V3615) V3757) (if (= () V3616) (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (if (shen.pvar? V3616) (do (shen.bindv V3616 () V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (do (shen.unbindv V3616 V3757) Result))) false)))) (if (shen.pvar? V3615) (let B (shen.newpv V3757) (do (shen.bindv V3615 (cons B ()) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (do (shen.unbindv V3615 V3757) Result)))) false))) (do (shen.unbindv V3612 V3757) Result))) false))) (if (shen.pvar? V3611) (let B (shen.newpv V3757) (do (shen.bindv V3611 (cons * (cons B ())) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (do (shen.unbindv V3611 V3757) Result)))) false)))) (if (shen.pvar? V3610) (let A (shen.newpv V3757) (let B (shen.newpv V3757) (do (shen.bindv V3610 (cons A (cons * (cons B ()))) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y B V3756 V3757 V3758)))) (do (shen.unbindv V3610 V3757) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3617 (shen.lazyderef V3754 V3757) (if (cons? V3617) (let V3618 (shen.lazyderef (hd V3617) V3757) (if (= @v V3618) (let V3619 (shen.lazyderef (tl V3617) V3757) (if (cons? V3619) (let X (hd V3619) (let V3620 (shen.lazyderef (tl V3619) V3757) (if (cons? V3620) (let Y (hd V3620) (let V3621 (shen.lazyderef (tl V3620) V3757) (if (= () V3621) (let V3622 (shen.lazyderef V3755 V3757) (if (cons? V3622) (let V3623 (shen.lazyderef (hd V3622) V3757) (if (= vector V3623) (let V3624 (shen.lazyderef (tl V3622) V3757) (if (cons? V3624) (let A (hd V3624) (let V3625 (shen.lazyderef (tl V3624) V3757) (if (= () V3625) (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (if (shen.pvar? V3625) (do (shen.bindv V3625 () V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3625 V3757) Result))) false)))) (if (shen.pvar? V3624) (let A (shen.newpv V3757) (do (shen.bindv V3624 (cons A ()) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3624 V3757) Result)))) false))) (if (shen.pvar? V3623) (do (shen.bindv V3623 vector V3757) (let Result (let V3626 (shen.lazyderef (tl V3622) V3757) (if (cons? V3626) (let A (hd V3626) (let V3627 (shen.lazyderef (tl V3626) V3757) (if (= () V3627) (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (if (shen.pvar? V3627) (do (shen.bindv V3627 () V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3627 V3757) Result))) false)))) (if (shen.pvar? V3626) (let A (shen.newpv V3757) (do (shen.bindv V3626 (cons A ()) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3626 V3757) Result)))) false))) (do (shen.unbindv V3623 V3757) Result))) false))) (if (shen.pvar? V3622) (let A (shen.newpv V3757) (do (shen.bindv V3622 (cons vector (cons A ())) V3757) (let Result (do (shen.incinfs) (shen.th* X A V3756 V3757 (freeze (shen.th* Y (cons vector (cons A ())) V3756 V3757 V3758)))) (do (shen.unbindv V3622 V3757) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3628 (shen.lazyderef V3754 V3757) (if (cons? V3628) (let V3629 (shen.lazyderef (hd V3628) V3757) (if (= @s V3629) (let V3630 (shen.lazyderef (tl V3628) V3757) (if (cons? V3630) (let X (hd V3630) (let V3631 (shen.lazyderef (tl V3630) V3757) (if (cons? V3631) (let Y (hd V3631) (let V3632 (shen.lazyderef (tl V3631) V3757) (if (= () V3632) (let V3633 (shen.lazyderef V3755 V3757) (if (= string V3633) (do (shen.incinfs) (shen.th* X string V3756 V3757 (freeze (shen.th* Y string V3756 V3757 V3758)))) (if (shen.pvar? V3633) (do (shen.bindv V3633 string V3757) (let Result (do (shen.incinfs) (shen.th* X string V3756 V3757 (freeze (shen.th* Y string V3756 V3757 V3758)))) (do (shen.unbindv V3633 V3757) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3634 (shen.lazyderef V3754 V3757) (if (cons? V3634) (let V3635 (shen.lazyderef (hd V3634) V3757) (if (= lambda V3635) (let V3636 (shen.lazyderef (tl V3634) V3757) (if (cons? V3636) (let X (hd V3636) (let V3637 (shen.lazyderef (tl V3636) V3757) (if (cons? V3637) (let Y (hd V3637) (let V3638 (shen.lazyderef (tl V3637) V3757) (if (= () V3638) (let V3639 (shen.lazyderef V3755 V3757) (if (cons? V3639) (let A (hd V3639) (let V3640 (shen.lazyderef (tl V3639) V3757) (if (cons? V3640) (let V3641 (shen.lazyderef (hd V3640) V3757) (if (= --> V3641) (let V3642 (shen.lazyderef (tl V3640) V3757) (if (cons? V3642) (let B (hd V3642) (let V3643 (shen.lazyderef (tl V3642) V3757) (if (= () V3643) (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (if (shen.pvar? V3643) (do (shen.bindv V3643 () V3757) (let Result (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (do (shen.unbindv V3643 V3757) Result))) false)))) (if (shen.pvar? V3642) (let B (shen.newpv V3757) (do (shen.bindv V3642 (cons B ()) V3757) (let Result (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (do (shen.unbindv V3642 V3757) Result)))) false))) (if (shen.pvar? V3641) (do (shen.bindv V3641 --> V3757) (let Result (let V3644 (shen.lazyderef (tl V3640) V3757) (if (cons? V3644) (let B (hd V3644) (let V3645 (shen.lazyderef (tl V3644) V3757) (if (= () V3645) (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (if (shen.pvar? V3645) (do (shen.bindv V3645 () V3757) (let Result (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (do (shen.unbindv V3645 V3757) Result))) false)))) (if (shen.pvar? V3644) (let B (shen.newpv V3757) (do (shen.bindv V3644 (cons B ()) V3757) (let Result (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (do (shen.unbindv V3644 V3757) Result)))) false))) (do (shen.unbindv V3641 V3757) Result))) false))) (if (shen.pvar? V3640) (let B (shen.newpv V3757) (do (shen.bindv V3640 (cons --> (cons B ())) V3757) (let Result (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (do (shen.unbindv V3640 V3757) Result)))) false)))) (if (shen.pvar? V3639) (let A (shen.newpv V3757) (let B (shen.newpv V3757) (do (shen.bindv V3639 (cons A (cons --> (cons B ()))) V3757) (let Result (let Z (shen.newpv V3757) (let X&& (shen.newpv V3757) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Y V3757)) V3757 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3756) V3757 V3758)))))))))) (do (shen.unbindv V3639 V3757) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3646 (shen.lazyderef V3754 V3757) (if (cons? V3646) (let V3647 (shen.lazyderef (hd V3646) V3757) (if (= let V3647) (let V3648 (shen.lazyderef (tl V3646) V3757) (if (cons? V3648) (let X (hd V3648) (let V3649 (shen.lazyderef (tl V3648) V3757) (if (cons? V3649) (let Y (hd V3649) (let V3650 (shen.lazyderef (tl V3649) V3757) (if (cons? V3650) (let Z (hd V3650) (let V3651 (shen.lazyderef (tl V3650) V3757) (if (= () V3651) (let W (shen.newpv V3757) (let X&& (shen.newpv V3757) (let B (shen.newpv V3757) (do (shen.incinfs) (shen.th* Y B V3756 V3757 (freeze (bind X&& (shen.placeholder) V3757 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3757) (shen.lazyderef X V3757) (shen.lazyderef Z V3757)) V3757 (freeze (shen.th* W V3755 (cons (cons X&& (cons : (cons B ()))) V3756) V3757 V3758))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3652 (shen.lazyderef V3754 V3757) (if (cons? V3652) (let V3653 (shen.lazyderef (hd V3652) V3757) (if (= open V3653) (let V3654 (shen.lazyderef (tl V3652) V3757) (if (cons? V3654) (let FileName (hd V3654) (let V3655 (shen.lazyderef (tl V3654) V3757) (if (cons? V3655) (let Direction3585 (hd V3655) (let V3656 (shen.lazyderef (tl V3655) V3757) (if (= () V3656) (let V3657 (shen.lazyderef V3755 V3757) (if (cons? V3657) (let V3658 (shen.lazyderef (hd V3657) V3757) (if (= stream V3658) (let V3659 (shen.lazyderef (tl V3657) V3757) (if (cons? V3659) (let Direction (hd V3659) (let V3660 (shen.lazyderef (tl V3659) V3757) (if (= () V3660) (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (if (shen.pvar? V3660) (do (shen.bindv V3660 () V3757) (let Result (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (do (shen.unbindv V3660 V3757) Result))) false)))) (if (shen.pvar? V3659) (let Direction (shen.newpv V3757) (do (shen.bindv V3659 (cons Direction ()) V3757) (let Result (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (do (shen.unbindv V3659 V3757) Result)))) false))) (if (shen.pvar? V3658) (do (shen.bindv V3658 stream V3757) (let Result (let V3661 (shen.lazyderef (tl V3657) V3757) (if (cons? V3661) (let Direction (hd V3661) (let V3662 (shen.lazyderef (tl V3661) V3757) (if (= () V3662) (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (if (shen.pvar? V3662) (do (shen.bindv V3662 () V3757) (let Result (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (do (shen.unbindv V3662 V3757) Result))) false)))) (if (shen.pvar? V3661) (let Direction (shen.newpv V3757) (do (shen.bindv V3661 (cons Direction ()) V3757) (let Result (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (do (shen.unbindv V3661 V3757) Result)))) false))) (do (shen.unbindv V3658 V3757) Result))) false))) (if (shen.pvar? V3657) (let Direction (shen.newpv V3757) (do (shen.bindv V3657 (cons stream (cons Direction ())) V3757) (let Result (do (shen.incinfs) (unify! Direction Direction3585 V3757 (freeze (cut Throwcontrol V3757 (freeze (fwhen (element? (shen.lazyderef Direction V3757) (cons in (cons out ()))) V3757 (freeze (shen.th* FileName string V3756 V3757 V3758)))))))) (do (shen.unbindv V3657 V3757) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3663 (shen.lazyderef V3754 V3757) (if (cons? V3663) (let V3664 (shen.lazyderef (hd V3663) V3757) (if (= type V3664) (let V3665 (shen.lazyderef (tl V3663) V3757) (if (cons? V3665) (let X (hd V3665) (let V3666 (shen.lazyderef (tl V3665) V3757) (if (cons? V3666) (let A (hd V3666) (let V3667 (shen.lazyderef (tl V3666) V3757) (if (= () V3667) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (unify A V3755 V3757 (freeze (shen.th* X A V3756 V3757 V3758)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3668 (shen.lazyderef V3754 V3757) (if (cons? V3668) (let V3669 (shen.lazyderef (hd V3668) V3757) (if (= input+ V3669) (let V3670 (shen.lazyderef (tl V3668) V3757) (if (cons? V3670) (let A (hd V3670) (let V3671 (shen.lazyderef (tl V3670) V3757) (if (cons? V3671) (let Stream (hd V3671) (let V3672 (shen.lazyderef (tl V3671) V3757) (if (= () V3672) (let C (shen.newpv V3757) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3757)) V3757 (freeze (unify V3755 C V3757 (freeze (shen.th* Stream (cons stream (cons in ())) V3756 V3757 V3758))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3673 (shen.lazyderef V3754 V3757) (if (cons? V3673) (let V3674 (shen.lazyderef (hd V3673) V3757) (if (= set V3674) (let V3675 (shen.lazyderef (tl V3673) V3757) (if (cons? V3675) (let Var (hd V3675) (let V3676 (shen.lazyderef (tl V3675) V3757) (if (cons? V3676) (let Val (hd V3676) (let V3677 (shen.lazyderef (tl V3676) V3757) (if (= () V3677) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (shen.th* Var symbol V3756 V3757 (freeze (cut Throwcontrol V3757 (freeze (shen.th* (cons value (cons Var ())) V3755 V3756 V3757 (freeze (shen.th* Val V3755 V3756 V3757 V3758)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3757) (do (shen.incinfs) (shen.t*-hyps V3756 NewHyp V3757 (freeze (shen.th* V3754 V3755 NewHyp V3757 V3758))))) (if (= Case false) (let Case (let V3678 (shen.lazyderef V3754 V3757) (if (cons? V3678) (let V3679 (shen.lazyderef (hd V3678) V3757) (if (= define V3679) (let V3680 (shen.lazyderef (tl V3678) V3757) (if (cons? V3680) (let F (hd V3680) (let X (tl V3680) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (shen.t*-def (cons define (cons F X)) V3755 V3756 V3757 V3758)))))) false)) false)) false)) (if (= Case false) (let Case (let V3681 (shen.lazyderef V3754 V3757) (if (cons? V3681) (let V3682 (shen.lazyderef (hd V3681) V3757) (if (= defmacro V3682) (let V3683 (shen.lazyderef V3755 V3757) (if (= unit V3683) (do (shen.incinfs) (cut Throwcontrol V3757 V3758)) (if (shen.pvar? V3683) (do (shen.bindv V3683 unit V3757) (let Result (do (shen.incinfs) (cut Throwcontrol V3757 V3758)) (do (shen.unbindv V3683 V3757) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3684 (shen.lazyderef V3754 V3757) (if (cons? V3684) (let V3685 (shen.lazyderef (hd V3684) V3757) (if (= shen.process-datatype V3685) (let V3686 (shen.lazyderef V3755 V3757) (if (= symbol V3686) (do (shen.incinfs) (thaw V3758)) (if (shen.pvar? V3686) (do (shen.bindv V3686 symbol V3757) (let Result (do (shen.incinfs) (thaw V3758)) (do (shen.unbindv V3686 V3757) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3687 (shen.lazyderef V3754 V3757) (if (cons? V3687) (let V3688 (shen.lazyderef (hd V3687) V3757) (if (= shen.synonyms-help V3688) (let V3689 (shen.lazyderef V3755 V3757) (if (= symbol V3689) (do (shen.incinfs) (thaw V3758)) (if (shen.pvar? V3689) (do (shen.bindv V3689 symbol V3757) (let Result (do (shen.incinfs) (thaw V3758)) (do (shen.unbindv V3689 V3757) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3757) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3757 (freeze (shen.udefs* (cons V3754 (cons : (cons V3755 ()))) V3756 Datatypes V3757 V3758))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3763 V3764 V3765 V3766) (let Case (let V3500 (shen.lazyderef V3763 V3765) (if (cons? V3500) (let V3501 (shen.lazyderef (hd V3500) V3765) (if (cons? V3501) (let V3502 (shen.lazyderef (hd V3501) V3765) (if (cons? V3502) (let V3503 (shen.lazyderef (hd V3502) V3765) (if (= cons V3503) (let V3504 (shen.lazyderef (tl V3502) V3765) (if (cons? V3504) (let X (hd V3504) (let V3505 (shen.lazyderef (tl V3504) V3765) (if (cons? V3505) (let Y (hd V3505) (let V3506 (shen.lazyderef (tl V3505) V3765) (if (= () V3506) (let V3507 (shen.lazyderef (tl V3501) V3765) (if (cons? V3507) (let V3508 (shen.lazyderef (hd V3507) V3765) (if (= : V3508) (let V3509 (shen.lazyderef (tl V3507) V3765) (if (cons? V3509) (let V3510 (shen.lazyderef (hd V3509) V3765) (if (cons? V3510) (let V3511 (shen.lazyderef (hd V3510) V3765) (if (= list V3511) (let V3512 (shen.lazyderef (tl V3510) V3765) (if (cons? V3512) (let A (hd V3512) (let V3513 (shen.lazyderef (tl V3512) V3765) (if (= () V3513) (let V3514 (shen.lazyderef (tl V3509) V3765) (if (= () V3514) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3514) (do (shen.bindv V3514 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3514 V3765) Result))) false))) (if (shen.pvar? V3513) (do (shen.bindv V3513 () V3765) (let Result (let V3515 (shen.lazyderef (tl V3509) V3765) (if (= () V3515) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3515) (do (shen.bindv V3515 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3515 V3765) Result))) false))) (do (shen.unbindv V3513 V3765) Result))) false)))) (if (shen.pvar? V3512) (let A (shen.newpv V3765) (do (shen.bindv V3512 (cons A ()) V3765) (let Result (let V3516 (shen.lazyderef (tl V3509) V3765) (if (= () V3516) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3516) (do (shen.bindv V3516 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3516 V3765) Result))) false))) (do (shen.unbindv V3512 V3765) Result)))) false))) (if (shen.pvar? V3511) (do (shen.bindv V3511 list V3765) (let Result (let V3517 (shen.lazyderef (tl V3510) V3765) (if (cons? V3517) (let A (hd V3517) (let V3518 (shen.lazyderef (tl V3517) V3765) (if (= () V3518) (let V3519 (shen.lazyderef (tl V3509) V3765) (if (= () V3519) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3519) (do (shen.bindv V3519 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3519 V3765) Result))) false))) (if (shen.pvar? V3518) (do (shen.bindv V3518 () V3765) (let Result (let V3520 (shen.lazyderef (tl V3509) V3765) (if (= () V3520) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3520) (do (shen.bindv V3520 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3520 V3765) Result))) false))) (do (shen.unbindv V3518 V3765) Result))) false)))) (if (shen.pvar? V3517) (let A (shen.newpv V3765) (do (shen.bindv V3517 (cons A ()) V3765) (let Result (let V3521 (shen.lazyderef (tl V3509) V3765) (if (= () V3521) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3521) (do (shen.bindv V3521 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3521 V3765) Result))) false))) (do (shen.unbindv V3517 V3765) Result)))) false))) (do (shen.unbindv V3511 V3765) Result))) false))) (if (shen.pvar? V3510) (let A (shen.newpv V3765) (do (shen.bindv V3510 (cons list (cons A ())) V3765) (let Result (let V3522 (shen.lazyderef (tl V3509) V3765) (if (= () V3522) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3522) (do (shen.bindv V3522 () V3765) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons list (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3522 V3765) Result))) false))) (do (shen.unbindv V3510 V3765) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3523 (shen.lazyderef V3763 V3765) (if (cons? V3523) (let V3524 (shen.lazyderef (hd V3523) V3765) (if (cons? V3524) (let V3525 (shen.lazyderef (hd V3524) V3765) (if (cons? V3525) (let V3526 (shen.lazyderef (hd V3525) V3765) (if (= @p V3526) (let V3527 (shen.lazyderef (tl V3525) V3765) (if (cons? V3527) (let X (hd V3527) (let V3528 (shen.lazyderef (tl V3527) V3765) (if (cons? V3528) (let Y (hd V3528) (let V3529 (shen.lazyderef (tl V3528) V3765) (if (= () V3529) (let V3530 (shen.lazyderef (tl V3524) V3765) (if (cons? V3530) (let V3531 (shen.lazyderef (hd V3530) V3765) (if (= : V3531) (let V3532 (shen.lazyderef (tl V3530) V3765) (if (cons? V3532) (let V3533 (shen.lazyderef (hd V3532) V3765) (if (cons? V3533) (let A (hd V3533) (let V3534 (shen.lazyderef (tl V3533) V3765) (if (cons? V3534) (let V3535 (shen.lazyderef (hd V3534) V3765) (if (= * V3535) (let V3536 (shen.lazyderef (tl V3534) V3765) (if (cons? V3536) (let B (hd V3536) (let V3537 (shen.lazyderef (tl V3536) V3765) (if (= () V3537) (let V3538 (shen.lazyderef (tl V3532) V3765) (if (= () V3538) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3538) (do (shen.bindv V3538 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3538 V3765) Result))) false))) (if (shen.pvar? V3537) (do (shen.bindv V3537 () V3765) (let Result (let V3539 (shen.lazyderef (tl V3532) V3765) (if (= () V3539) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3539) (do (shen.bindv V3539 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3539 V3765) Result))) false))) (do (shen.unbindv V3537 V3765) Result))) false)))) (if (shen.pvar? V3536) (let B (shen.newpv V3765) (do (shen.bindv V3536 (cons B ()) V3765) (let Result (let V3540 (shen.lazyderef (tl V3532) V3765) (if (= () V3540) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3540) (do (shen.bindv V3540 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3540 V3765) Result))) false))) (do (shen.unbindv V3536 V3765) Result)))) false))) (if (shen.pvar? V3535) (do (shen.bindv V3535 * V3765) (let Result (let V3541 (shen.lazyderef (tl V3534) V3765) (if (cons? V3541) (let B (hd V3541) (let V3542 (shen.lazyderef (tl V3541) V3765) (if (= () V3542) (let V3543 (shen.lazyderef (tl V3532) V3765) (if (= () V3543) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3543) (do (shen.bindv V3543 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3543 V3765) Result))) false))) (if (shen.pvar? V3542) (do (shen.bindv V3542 () V3765) (let Result (let V3544 (shen.lazyderef (tl V3532) V3765) (if (= () V3544) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3544) (do (shen.bindv V3544 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3544 V3765) Result))) false))) (do (shen.unbindv V3542 V3765) Result))) false)))) (if (shen.pvar? V3541) (let B (shen.newpv V3765) (do (shen.bindv V3541 (cons B ()) V3765) (let Result (let V3545 (shen.lazyderef (tl V3532) V3765) (if (= () V3545) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3545) (do (shen.bindv V3545 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3545 V3765) Result))) false))) (do (shen.unbindv V3541 V3765) Result)))) false))) (do (shen.unbindv V3535 V3765) Result))) false))) (if (shen.pvar? V3534) (let B (shen.newpv V3765) (do (shen.bindv V3534 (cons * (cons B ())) V3765) (let Result (let V3546 (shen.lazyderef (tl V3532) V3765) (if (= () V3546) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3546) (do (shen.bindv V3546 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3546 V3765) Result))) false))) (do (shen.unbindv V3534 V3765) Result)))) false)))) (if (shen.pvar? V3533) (let A (shen.newpv V3765) (let B (shen.newpv V3765) (do (shen.bindv V3533 (cons A (cons * (cons B ()))) V3765) (let Result (let V3547 (shen.lazyderef (tl V3532) V3765) (if (= () V3547) (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3547) (do (shen.bindv V3547 () V3765) (let Result (let Hyp (tl V3523) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (shen.lazyderef B V3765) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3547 V3765) Result))) false))) (do (shen.unbindv V3533 V3765) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3548 (shen.lazyderef V3763 V3765) (if (cons? V3548) (let V3549 (shen.lazyderef (hd V3548) V3765) (if (cons? V3549) (let V3550 (shen.lazyderef (hd V3549) V3765) (if (cons? V3550) (let V3551 (shen.lazyderef (hd V3550) V3765) (if (= @v V3551) (let V3552 (shen.lazyderef (tl V3550) V3765) (if (cons? V3552) (let X (hd V3552) (let V3553 (shen.lazyderef (tl V3552) V3765) (if (cons? V3553) (let Y (hd V3553) (let V3554 (shen.lazyderef (tl V3553) V3765) (if (= () V3554) (let V3555 (shen.lazyderef (tl V3549) V3765) (if (cons? V3555) (let V3556 (shen.lazyderef (hd V3555) V3765) (if (= : V3556) (let V3557 (shen.lazyderef (tl V3555) V3765) (if (cons? V3557) (let V3558 (shen.lazyderef (hd V3557) V3765) (if (cons? V3558) (let V3559 (shen.lazyderef (hd V3558) V3765) (if (= vector V3559) (let V3560 (shen.lazyderef (tl V3558) V3765) (if (cons? V3560) (let A (hd V3560) (let V3561 (shen.lazyderef (tl V3560) V3765) (if (= () V3561) (let V3562 (shen.lazyderef (tl V3557) V3765) (if (= () V3562) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3562) (do (shen.bindv V3562 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3562 V3765) Result))) false))) (if (shen.pvar? V3561) (do (shen.bindv V3561 () V3765) (let Result (let V3563 (shen.lazyderef (tl V3557) V3765) (if (= () V3563) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3563) (do (shen.bindv V3563 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3563 V3765) Result))) false))) (do (shen.unbindv V3561 V3765) Result))) false)))) (if (shen.pvar? V3560) (let A (shen.newpv V3765) (do (shen.bindv V3560 (cons A ()) V3765) (let Result (let V3564 (shen.lazyderef (tl V3557) V3765) (if (= () V3564) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3564) (do (shen.bindv V3564 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3564 V3765) Result))) false))) (do (shen.unbindv V3560 V3765) Result)))) false))) (if (shen.pvar? V3559) (do (shen.bindv V3559 vector V3765) (let Result (let V3565 (shen.lazyderef (tl V3558) V3765) (if (cons? V3565) (let A (hd V3565) (let V3566 (shen.lazyderef (tl V3565) V3765) (if (= () V3566) (let V3567 (shen.lazyderef (tl V3557) V3765) (if (= () V3567) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3567) (do (shen.bindv V3567 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3567 V3765) Result))) false))) (if (shen.pvar? V3566) (do (shen.bindv V3566 () V3765) (let Result (let V3568 (shen.lazyderef (tl V3557) V3765) (if (= () V3568) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3568) (do (shen.bindv V3568 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3568 V3765) Result))) false))) (do (shen.unbindv V3566 V3765) Result))) false)))) (if (shen.pvar? V3565) (let A (shen.newpv V3765) (do (shen.bindv V3565 (cons A ()) V3765) (let Result (let V3569 (shen.lazyderef (tl V3557) V3765) (if (= () V3569) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3569) (do (shen.bindv V3569 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3569 V3765) Result))) false))) (do (shen.unbindv V3565 V3765) Result)))) false))) (do (shen.unbindv V3559 V3765) Result))) false))) (if (shen.pvar? V3558) (let A (shen.newpv V3765) (do (shen.bindv V3558 (cons vector (cons A ())) V3765) (let Result (let V3570 (shen.lazyderef (tl V3557) V3765) (if (= () V3570) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3570) (do (shen.bindv V3570 () V3765) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons (shen.lazyderef A V3765) ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons (cons vector (cons (shen.lazyderef A V3765) ())) ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3570 V3765) Result))) false))) (do (shen.unbindv V3558 V3765) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3571 (shen.lazyderef V3763 V3765) (if (cons? V3571) (let V3572 (shen.lazyderef (hd V3571) V3765) (if (cons? V3572) (let V3573 (shen.lazyderef (hd V3572) V3765) (if (cons? V3573) (let V3574 (shen.lazyderef (hd V3573) V3765) (if (= @s V3574) (let V3575 (shen.lazyderef (tl V3573) V3765) (if (cons? V3575) (let X (hd V3575) (let V3576 (shen.lazyderef (tl V3575) V3765) (if (cons? V3576) (let Y (hd V3576) (let V3577 (shen.lazyderef (tl V3576) V3765) (if (= () V3577) (let V3578 (shen.lazyderef (tl V3572) V3765) (if (cons? V3578) (let V3579 (shen.lazyderef (hd V3578) V3765) (if (= : V3579) (let V3580 (shen.lazyderef (tl V3578) V3765) (if (cons? V3580) (let V3581 (shen.lazyderef (hd V3580) V3765) (if (= string V3581) (let V3582 (shen.lazyderef (tl V3580) V3765) (if (= () V3582) (let Hyp (tl V3571) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons string ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3582) (do (shen.bindv V3582 () V3765) (let Result (let Hyp (tl V3571) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons string ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3582 V3765) Result))) false))) (if (shen.pvar? V3581) (do (shen.bindv V3581 string V3765) (let Result (let V3583 (shen.lazyderef (tl V3580) V3765) (if (= () V3583) (let Hyp (tl V3571) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons string ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (if (shen.pvar? V3583) (do (shen.bindv V3583 () V3765) (let Result (let Hyp (tl V3571) (do (shen.incinfs) (bind V3764 (cons (cons (shen.lazyderef X V3765) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3765) (cons : (cons string ()))) (shen.lazyderef Hyp V3765))) V3765 V3766))) (do (shen.unbindv V3583 V3765) Result))) false))) (do (shen.unbindv V3581 V3765) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3584 (shen.lazyderef V3763 V3765) (if (cons? V3584) (let X (hd V3584) (let Hyp (tl V3584) (let NewHyps (shen.newpv V3765) (do (shen.incinfs) (bind V3764 (cons (shen.lazyderef X V3765) (shen.lazyderef NewHyps V3765)) V3765 (freeze (shen.t*-hyps Hyp NewHyps V3765 V3766))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3783 V3784 V3785 V3786) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3783 V3785)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3784 V3785) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3786))))))))) (true (thaw V3786))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3788) (cond ((and (cons? V3788) (and (cons? (tl V3788)) (and (= : (hd (tl V3788))) (and (cons? (tl (tl V3788))) (= () (tl (tl (tl V3788)))))))) (shen.prhush (shen.app (hd V3788) (cn " : " (shen.app (hd (tl (tl V3788))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3788 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3793 V3794) (cond ((= () V3793) shen.skip) ((cons? V3793) (do (shen.prhush (shen.app V3794 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3793)) (do (nl 1) (shen.show-assumptions (tl V3793) (+ V3794 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3796) (cons? (assoc V3796 (value shen.*signedfuncs*))))

(defun shen.sigf (V3798) (concat shen.type-signature-of- V3798))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3803 V3804 V3805 V3806) (let Case (let V3487 (shen.lazyderef V3804 V3805) (if (= number V3487) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3803 V3805)) V3805 V3806)) (if (shen.pvar? V3487) (do (shen.bindv V3487 number V3805) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3803 V3805)) V3805 V3806)) (do (shen.unbindv V3487 V3805) Result))) false))) (if (= Case false) (let Case (let V3488 (shen.lazyderef V3804 V3805) (if (= boolean V3488) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3803 V3805)) V3805 V3806)) (if (shen.pvar? V3488) (do (shen.bindv V3488 boolean V3805) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3803 V3805)) V3805 V3806)) (do (shen.unbindv V3488 V3805) Result))) false))) (if (= Case false) (let Case (let V3489 (shen.lazyderef V3804 V3805) (if (= string V3489) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3803 V3805)) V3805 V3806)) (if (shen.pvar? V3489) (do (shen.bindv V3489 string V3805) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3803 V3805)) V3805 V3806)) (do (shen.unbindv V3489 V3805) Result))) false))) (if (= Case false) (let Case (let V3490 (shen.lazyderef V3804 V3805) (if (= symbol V3490) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3803 V3805)) V3805 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3803 V3805))) V3805 V3806)))) (if (shen.pvar? V3490) (do (shen.bindv V3490 symbol V3805) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3803 V3805)) V3805 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3803 V3805))) V3805 V3806)))) (do (shen.unbindv V3490 V3805) Result))) false))) (if (= Case false) (let V3491 (shen.lazyderef V3803 V3805) (if (= () V3491) (let V3492 (shen.lazyderef V3804 V3805) (if (cons? V3492) (let V3493 (shen.lazyderef (hd V3492) V3805) (if (= list V3493) (let V3494 (shen.lazyderef (tl V3492) V3805) (if (cons? V3494) (let A (hd V3494) (let V3495 (shen.lazyderef (tl V3494) V3805) (if (= () V3495) (do (shen.incinfs) (thaw V3806)) (if (shen.pvar? V3495) (do (shen.bindv V3495 () V3805) (let Result (do (shen.incinfs) (thaw V3806)) (do (shen.unbindv V3495 V3805) Result))) false)))) (if (shen.pvar? V3494) (let A (shen.newpv V3805) (do (shen.bindv V3494 (cons A ()) V3805) (let Result (do (shen.incinfs) (thaw V3806)) (do (shen.unbindv V3494 V3805) Result)))) false))) (if (shen.pvar? V3493) (do (shen.bindv V3493 list V3805) (let Result (let V3496 (shen.lazyderef (tl V3492) V3805) (if (cons? V3496) (let A (hd V3496) (let V3497 (shen.lazyderef (tl V3496) V3805) (if (= () V3497) (do (shen.incinfs) (thaw V3806)) (if (shen.pvar? V3497) (do (shen.bindv V3497 () V3805) (let Result (do (shen.incinfs) (thaw V3806)) (do (shen.unbindv V3497 V3805) Result))) false)))) (if (shen.pvar? V3496) (let A (shen.newpv V3805) (do (shen.bindv V3496 (cons A ()) V3805) (let Result (do (shen.incinfs) (thaw V3806)) (do (shen.unbindv V3496 V3805) Result)))) false))) (do (shen.unbindv V3493 V3805) Result))) false))) (if (shen.pvar? V3492) (let A (shen.newpv V3805) (do (shen.bindv V3492 (cons list (cons A ())) V3805) (let Result (do (shen.incinfs) (thaw V3806)) (do (shen.unbindv V3492 V3805) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3812 V3813 V3814 V3815 V3816) (let Case (let V3478 (shen.lazyderef V3814 V3815) (if (cons? V3478) (let V3479 (shen.lazyderef (hd V3478) V3815) (if (cons? V3479) (let Y (hd V3479) (let V3480 (shen.lazyderef (tl V3479) V3815) (if (cons? V3480) (let V3481 (shen.lazyderef (hd V3480) V3815) (if (= : V3481) (let V3482 (shen.lazyderef (tl V3480) V3815) (if (cons? V3482) (let B (hd V3482) (let V3483 (shen.lazyderef (tl V3482) V3815) (if (= () V3483) (do (shen.incinfs) (identical V3812 Y V3815 (freeze (unify! V3813 B V3815 V3816)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3484 (shen.lazyderef V3814 V3815) (if (cons? V3484) (let Hyp (tl V3484) (do (shen.incinfs) (shen.by_hypothesis V3812 V3813 Hyp V3815 V3816))) false)) Case)))

(defun shen.t*-def (V3822 V3823 V3824 V3825 V3826) (let V3472 (shen.lazyderef V3822 V3825) (if (cons? V3472) (let V3473 (shen.lazyderef (hd V3472) V3825) (if (= define V3473) (let V3474 (shen.lazyderef (tl V3472) V3825) (if (cons? V3474) (let F (hd V3474) (let X (tl V3474) (let Y (shen.newpv V3825) (let E (shen.newpv V3825) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3823 V3824 V3825 V3826)))))) false)) false)) false)))

(defun shen.t*-defh (V3833 V3834 V3835 V3836 V3837 V3838) (let V3468 (shen.lazyderef V3833 V3837) (if (cons? V3468) (let Sig (hd V3468) (let Rules (tl V3468) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3834 V3835 V3836 Rules V3837 V3838)))) false)))

(defun shen.t*-defhh (V3847 V3848 V3849 V3850 V3851 V3852 V3853 V3854) (do (shen.incinfs) (shen.t*-rules V3852 V3848 1 V3849 (cons (cons V3849 (cons : (cons V3848 ()))) V3851) V3853 (freeze (shen.memo V3849 V3847 V3850 V3853 V3854)))))

(defun shen.memo (V3860 V3861 V3862 V3863 V3864) (let Jnk (shen.newpv V3863) (do (shen.incinfs) (unify! V3862 V3861 V3863 (freeze (bind Jnk (declare (shen.lazyderef V3860 V3863) (shen.lazyderef V3862 V3863)) V3863 V3864))))))

(defun shen.<sig+rules> (V3866) (let Parse_shen.<signature> (shen.<signature> V3866) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3868) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3868) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3868) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3870) (cond ((and (cons? V3870) (and (cons? (tl V3870)) (and (= () (tl (tl V3870))) (= (hd V3870) protect)))) V3870) ((cons? V3870) (map (lambda Z (shen.ue Z)) V3870)) ((variable? V3870) (concat && V3870)) (true V3870)))

(defun shen.ue-sig (V3872) (cond ((cons? V3872) (map (lambda Z (shen.ue-sig Z)) V3872)) ((variable? V3872) (concat &&& V3872)) (true V3872)))

(defun shen.ues (V3878) (cond ((shen.ue? V3878) (cons V3878 ())) ((cons? V3878) (union (shen.ues (hd V3878)) (shen.ues (tl V3878)))) (true ())))

(defun shen.ue? (V3880) (and (symbol? V3880) (shen.ue-h? (str V3880))))

(defun shen.ue-h? (V3888) (cond ((and (shen.+string? V3888) (and (= "&" (pos V3888 0)) (and (shen.+string? (tlstr V3888)) (= "&" (pos (tlstr V3888) 0))))) true) (true false)))

(defun shen.t*-rules (V3896 V3897 V3898 V3899 V3900 V3901 V3902) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3452 (shen.lazyderef V3896 V3901) (if (= () V3452) (do (shen.incinfs) (thaw V3902)) false)) (if (= Case false) (let Case (let V3453 (shen.lazyderef V3896 V3901) (if (cons? V3453) (let Rule (hd V3453) (let Rules (tl V3453) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3897 V3900 V3901 (freeze (cut Throwcontrol V3901 (freeze (shen.t*-rules Rules V3897 (+ V3898 1) V3899 V3900 V3901 V3902)))))))) false)) (if (= Case false) (let Err (shen.newpv V3901) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3898 V3901) (cn " of " (shen.app (shen.lazyderef V3899 V3901) "" shen.a)) shen.a))) V3901 V3902))) Case)) Case)))))

(defun shen.t*-rule (V3908 V3909 V3910 V3911 V3912) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3444 (shen.lazyderef V3908 V3911) (if (cons? V3444) (let Patterns (hd V3444) (let V3445 (shen.lazyderef (tl V3444) V3911) (if (cons? V3445) (let Action (hd V3445) (let V3446 (shen.lazyderef (tl V3445) V3911) (if (= () V3446) (let NewHyps (shen.newpv V3911) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3910 NewHyps V3911 (freeze (shen.t*-patterns Patterns V3909 NewHyps V3911 (freeze (cut Throwcontrol V3911 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3909) (shen.patthyps Patterns V3909 V3910) V3911 V3912))))))))) false))) false))) false)))))

(defun shen.placeholders (V3918) (cond ((shen.ue? V3918) (cons V3918 ())) ((cons? V3918) (union (shen.placeholders (hd V3918)) (shen.placeholders (tl V3918)))) (true ())))

(defun shen.newhyps (V3924 V3925 V3926 V3927 V3928) (let Case (let V3431 (shen.lazyderef V3924 V3927) (if (= () V3431) (do (shen.incinfs) (unify! V3926 V3925 V3927 V3928)) false)) (if (= Case false) (let V3432 (shen.lazyderef V3924 V3927) (if (cons? V3432) (let V3427 (hd V3432) (let Vs (tl V3432) (let V3433 (shen.lazyderef V3926 V3927) (if (cons? V3433) (let V3434 (shen.lazyderef (hd V3433) V3927) (if (cons? V3434) (let V (hd V3434) (let V3435 (shen.lazyderef (tl V3434) V3927) (if (cons? V3435) (let V3436 (shen.lazyderef (hd V3435) V3927) (if (= : V3436) (let V3437 (shen.lazyderef (tl V3435) V3927) (if (cons? V3437) (let A (hd V3437) (let V3438 (shen.lazyderef (tl V3437) V3927) (if (= () V3438) (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (if (shen.pvar? V3438) (do (shen.bindv V3438 () V3927) (let Result (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (do (shen.unbindv V3438 V3927) Result))) false)))) (if (shen.pvar? V3437) (let A (shen.newpv V3927) (do (shen.bindv V3437 (cons A ()) V3927) (let Result (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (do (shen.unbindv V3437 V3927) Result)))) false))) (if (shen.pvar? V3436) (do (shen.bindv V3436 : V3927) (let Result (let V3439 (shen.lazyderef (tl V3435) V3927) (if (cons? V3439) (let A (hd V3439) (let V3440 (shen.lazyderef (tl V3439) V3927) (if (= () V3440) (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (if (shen.pvar? V3440) (do (shen.bindv V3440 () V3927) (let Result (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (do (shen.unbindv V3440 V3927) Result))) false)))) (if (shen.pvar? V3439) (let A (shen.newpv V3927) (do (shen.bindv V3439 (cons A ()) V3927) (let Result (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (do (shen.unbindv V3439 V3927) Result)))) false))) (do (shen.unbindv V3436 V3927) Result))) false))) (if (shen.pvar? V3435) (let A (shen.newpv V3927) (do (shen.bindv V3435 (cons : (cons A ())) V3927) (let Result (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (do (shen.unbindv V3435 V3927) Result)))) false)))) (if (shen.pvar? V3434) (let V (shen.newpv V3927) (let A (shen.newpv V3927) (do (shen.bindv V3434 (cons V (cons : (cons A ()))) V3927) (let Result (let NewHyp (tl V3433) (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928))))) (do (shen.unbindv V3434 V3927) Result))))) false))) (if (shen.pvar? V3433) (let V (shen.newpv V3927) (let A (shen.newpv V3927) (let NewHyp (shen.newpv V3927) (do (shen.bindv V3433 (cons (cons V (cons : (cons A ()))) NewHyp) V3927) (let Result (do (shen.incinfs) (unify! V V3427 V3927 (freeze (shen.newhyps Vs V3925 NewHyp V3927 V3928)))) (do (shen.unbindv V3433 V3927) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3934 V3935 V3936) (cond ((= () V3934) V3936) ((and (cons? V3934) (and (cons? V3935) (and (cons? (tl V3935)) (and (= --> (hd (tl V3935))) (and (cons? (tl (tl V3935))) (= () (tl (tl (tl V3935))))))))) (adjoin (cons (hd V3934) (cons : (cons (hd V3935) ()))) (shen.patthyps (tl V3934) (hd (tl (tl V3935))) V3936))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3943 V3944) (cond ((and (= () V3943) (and (cons? V3944) (and (= --> (hd V3944)) (and (cons? (tl V3944)) (= () (tl (tl V3944))))))) (hd (tl V3944))) ((= () V3943) V3944) ((and (cons? V3943) (and (cons? V3944) (and (cons? (tl V3944)) (and (= --> (hd (tl V3944))) (and (cons? (tl (tl V3944))) (= () (tl (tl (tl V3944))))))))) (shen.result-type (tl V3943) (hd (tl (tl V3944))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3950 V3951 V3952 V3953 V3954) (let Case (let V3419 (shen.lazyderef V3950 V3953) (if (= () V3419) (do (shen.incinfs) (thaw V3954)) false)) (if (= Case false) (let V3420 (shen.lazyderef V3950 V3953) (if (cons? V3420) (let Pattern (hd V3420) (let Patterns (tl V3420) (let V3421 (shen.lazyderef V3951 V3953) (if (cons? V3421) (let A (hd V3421) (let V3422 (shen.lazyderef (tl V3421) V3953) (if (cons? V3422) (let V3423 (shen.lazyderef (hd V3422) V3953) (if (= --> V3423) (let V3424 (shen.lazyderef (tl V3422) V3953) (if (cons? V3424) (let B (hd V3424) (let V3425 (shen.lazyderef (tl V3424) V3953) (if (= () V3425) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3952 V3953 (freeze (shen.t*-patterns Patterns B V3952 V3953 V3954)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3960 V3961 V3962 V3963 V3964) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3396 (shen.lazyderef V3960 V3963) (if (cons? V3396) (let V3397 (shen.lazyderef (hd V3396) V3963) (if (= where V3397) (let V3398 (shen.lazyderef (tl V3396) V3963) (if (cons? V3398) (let P (hd V3398) (let V3399 (shen.lazyderef (tl V3398) V3963) (if (cons? V3399) (let Action (hd V3399) (let V3400 (shen.lazyderef (tl V3399) V3963) (if (= () V3400) (do (shen.incinfs) (cut Throwcontrol V3963 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3962 V3963 (freeze (cut Throwcontrol V3963 (freeze (shen.t*-action Action V3961 (cons (cons P (cons : (cons verified ()))) V3962) V3963 V3964)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3401 (shen.lazyderef V3960 V3963) (if (cons? V3401) (let V3402 (shen.lazyderef (hd V3401) V3963) (if (= shen.choicepoint! V3402) (let V3403 (shen.lazyderef (tl V3401) V3963) (if (cons? V3403) (let V3404 (shen.lazyderef (hd V3403) V3963) (if (cons? V3404) (let V3405 (shen.lazyderef (hd V3404) V3963) (if (cons? V3405) (let V3406 (shen.lazyderef (hd V3405) V3963) (if (= fail-if V3406) (let V3407 (shen.lazyderef (tl V3405) V3963) (if (cons? V3407) (let F (hd V3407) (let V3408 (shen.lazyderef (tl V3407) V3963) (if (= () V3408) (let V3409 (shen.lazyderef (tl V3404) V3963) (if (cons? V3409) (let Action (hd V3409) (let V3410 (shen.lazyderef (tl V3409) V3963) (if (= () V3410) (let V3411 (shen.lazyderef (tl V3403) V3963) (if (= () V3411) (do (shen.incinfs) (cut Throwcontrol V3963 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3961 V3962 V3963 V3964)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3412 (shen.lazyderef V3960 V3963) (if (cons? V3412) (let V3413 (shen.lazyderef (hd V3412) V3963) (if (= shen.choicepoint! V3413) (let V3414 (shen.lazyderef (tl V3412) V3963) (if (cons? V3414) (let Action (hd V3414) (let V3415 (shen.lazyderef (tl V3414) V3963) (if (= () V3415) (do (shen.incinfs) (cut Throwcontrol V3963 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3961 V3962 V3963 V3964)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3960 (cons : (cons V3961 ()))) V3962 V3963 V3964)) Case)) Case)) Case)))))

(defun findall (V3970 V3971 V3972 V3973 V3974) (let B (shen.newpv V3973) (let A (shen.newpv V3973) (do (shen.incinfs) (bind A (gensym shen.a) V3973 (freeze (bind B (set (shen.lazyderef A V3973) ()) V3973 (freeze (shen.findallhelp V3970 V3971 V3972 A V3973 V3974)))))))))

(defun shen.findallhelp (V3981 V3982 V3983 V3984 V3985 V3986) (let Case (do (shen.incinfs) (call V3982 V3985 (freeze (shen.remember V3984 V3981 V3985 (freeze (fwhen false V3985 V3986)))))) (if (= Case false) (do (shen.incinfs) (bind V3983 (value (shen.lazyderef V3984 V3985)) V3985 V3986)) Case)))

(defun shen.remember (V3991 V3992 V3993 V3994) (let B (shen.newpv V3993) (do (shen.incinfs) (bind B (set (shen.deref V3991 V3993) (cons (shen.deref V3992 V3993) (value (shen.deref V3991 V3993)))) V3993 V3994))))



